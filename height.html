
<!DOCTYPE html>
<script src='https://cdnjs.cloudflare.com/ajax/libs/three.js/r71/three.js'></script>
<script src='SimplexNoise.js'></script>
<script src='threex.terrain.js'></script>
<script id="vertexShader" type="x-shader/x-vertex">
uniform sampler2D bumpTexture;
uniform float bumpScale;

varying float vAmount;
varying vec2 vUV;

void main() 
{ 
	vUV = uv;
	vec4 bumpData = texture2D( bumpTexture, uv );
	
	vAmount = bumpData.r+0.07; // assuming map is grayscale it doesn't matter if you use r, g, or b.
	
	// move the position along the normal
    //vec3 newPosition = position + normal* bumpScale * 1.0;
	
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}
</script>

<!-- fragment shader a.k.a. pixel shader -->
<script id="fragmentShader" type="x-shader/x-vertex"> 
uniform sampler2D oceanTexture;
uniform sampler2D sandyTexture;
uniform sampler2D grassTexture;
uniform sampler2D rockyTexture;
uniform sampler2D snowyTexture;

varying vec2 vUV;

varying float vAmount;

void main() 
{

	vec4 water = (smoothstep(0.01, 0.25, vAmount) - smoothstep(0.24, 0.26, vAmount)) * texture2D( oceanTexture, vUV * 10.0 );
	vec4 sandy = (smoothstep(0.24, 0.27, vAmount) - smoothstep(0.28, 0.31, vAmount)) * texture2D( sandyTexture, vUV * 10.0 );
	vec4 grass = (smoothstep(0.28, 0.32, vAmount) - smoothstep(0.35, 0.40, vAmount)) * texture2D( grassTexture, vUV * 20.0 );
	vec4 rocky = (smoothstep(0.30, 0.50, vAmount) - smoothstep(0.40, 0.70, vAmount)) * texture2D( rockyTexture, vUV * 20.0 );
	vec4 snowy = (smoothstep(0.50, 0.65, vAmount))                                   * texture2D( snowyTexture, vUV * 10.0 );
	gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0) +water + sandy + grass + rocky + snowy; //, 1.0);
}  
</script>
<body style='margin: 0px; background-color: #bbbbbb; overflow: hidden;'><script>
	var renderer	= new THREE.WebGLRenderer();
	renderer.setSize( window.innerWidth, window.innerHeight );
	document.body.appendChild( renderer.domElement );
var loadImage = function(url) {
    return THREE.ImageUtils.loadTexture(url,null,function(){});
}
	var onRenderFcts= [];
	var scene	= new THREE.Scene();
	var camera	= new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.01, 1000000);
	camera.position.z = 180

	;(function(){
		// add a ambient light
		var light	= new THREE.AmbientLight( 0x666666)
		scene.add( light )
		// add a light in front
		var light	= new THREE.DirectionalLight('0xccddee', 2)
		light.position.set(0.5, 0.0, 2)
		scene.add( light )
		var light	= new THREE.DirectionalLight('white', 5)
		light.position.set(0.5, 0.0, 2)
		scene.add( light )
		// add a light behind
		var light	= new THREE.DirectionalLight('white', 0.75*2)
		light.position.set(-0.5, -0.5, -2)
		scene.add( light )		
		hemiLight = new THREE.HemisphereLight( 0x0000ff, 0x00ff00, 0.6 ); 
		scene.add( hemiLight )		
		
	})()


var heightMap,mesh,geometry,material;


  // GROUD
        var oceanTexture = new loadImage( 'dirt-512.jpg' );
        oceanTexture.wrapS = oceanTexture.wrapT = THREE.RepeatWrapping; 
        
        var sandyTexture = new loadImage( 'sand-512.jpg' );
        sandyTexture.wrapS = sandyTexture.wrapT = THREE.RepeatWrapping; 
        
        var grassTexture = new loadImage( 'grass-512.jpg' );
        grassTexture.wrapS = grassTexture.wrapT = THREE.RepeatWrapping; 
        
        var rockyTexture = new loadImage( 'rock-512.jpg' );
        rockyTexture.wrapS = rockyTexture.wrapT = THREE.RepeatWrapping; 
        
        var snowyTexture = new loadImage( 'snow-512.jpg' );
        snowyTexture.wrapS = snowyTexture.wrapT = THREE.RepeatWrapping; 


	



for (var i = 0; i < 4; i++) {
for (var j = 0; j < 4; j++) {

	 heightMap	= THREEx.Terrain.allocateHeightMap(64, 64)
	THREEx.Terrain.simplexHeightMap(heightMap,63*i,63*j)
		
	 geometry	= THREEx.Terrain.heightMapToPlaneGeometry(heightMap)
	THREEx.Terrain.heightMapToVertexColor(heightMap, geometry)

	var canvas	= THREEx.Terrain.heightMapToCanvas(heightMap)

	document.body.appendChild(canvas)


var texture = new THREE.Texture(canvas);
texture.needsUpdate = true;

// use "this." to create global object
	var customUniforms = {
		bumpTexture:	{ type: "t", value: texture },
		bumpScale:	    { type: "f", value: 1.0 },
		oceanTexture:	{ type: "t", value: oceanTexture },
		sandyTexture:	{ type: "t", value: sandyTexture },
		grassTexture:	{ type: "t", value: grassTexture },
		rockyTexture:	{ type: "t", value: rockyTexture },
		snowyTexture:	{ type: "t", value: snowyTexture },
	};
	
	// create custom material from the shader code above
	//   that is within specially labelled script tags
	var material = new THREE.ShaderMaterial( 
	{
	    uniforms: customUniforms,
		vertexShader:   document.getElementById( 'vertexShader'   ).textContent,
		fragmentShader: document.getElementById( 'fragmentShader' ).textContent,
		// side: THREE.DoubleSide
	}   );
	 mesh	= new THREE.Mesh( geometry, material );
	scene.add( mesh );
	mesh.rotateX(-Math.PI/2)
	mesh.position.x	= 10000*i-1000 
	mesh.position.z	= 10000*j-1000
	mesh.position.y	-= 1000
	 mesh.scale.z	= 0.01
	mesh.scale.multiplyScalar(10000) 
	
}
}	

;(function(planeMesh){
	var testPosition= new THREE.Vector3(-0.5,0,-0.5)
	var testPosition= new THREE.Vector3(+0.5-0.2-0.2,0,-0.5+0.1)
	var testPosition= new THREE.Vector3((+0.5-0.2) * planeMesh.scale.x,0,(-0.5+0.2)*planeMesh.scale.y)
	// TODO assert no rotation in planeMesh ... how to do that ?

	var geometry	= new THREE.CubeGeometry(0.01, 1, 0.01)
	// var geometry	= new THREE.SphereGeometry(0.05)
	var material	= new THREE.MeshNormalMaterial()
	var mesh	= new THREE.Mesh(geometry, material)
	mesh.position	= testPosition
	scene.add(mesh)

	var mesh	= new THREE.Mesh(new THREE.SphereGeometry(0.05), new THREE.MeshNormalMaterial())
	mesh.position	= testPosition
	scene.add(mesh)

console.log('testPosition.x', testPosition.x)

console.log('testPosition.x', testPosition, planeMesh)
	onRenderFcts.push(function(delta){
	// return
		/*var position	= mesh.position
		position.x	+= 0.005 * planeMesh.scale.x
		if( position.x > 0.5 * planeMesh.scale.x ){
			position.x	= -0.5 * planeMesh.scale.x
			position.z	+= 0.05 * planeMesh.scale.y
		}
		if( position.z > 0.5 * planeMesh.scale.y){
			position.x	= -0.5 * planeMesh.scale.x
			position.z	= -0.5 * planeMesh.scale.y			
		}


		testPosition.y	= THREEx.Terrain.planeToHeightMapCoords(heightMap, planeMesh, testPosition.x, testPosition.z)*/
	})
})(mesh)


	var mouse	= {x : 0, y : 0}
	document.addEventListener('mousemove', function(event){
		mouse.x	= (event.clientX / window.innerWidth ) - 0.5
		mouse.y	= (event.clientY / window.innerHeight) - 0.5
	}, false)
	onRenderFcts.push(function(delta, now){
		camera.position.x += (mouse.x*50000 - camera.position.x) * (delta*3)+1000
		camera.position.y += (mouse.y*50000 - (camera.position.y-4)) * (delta*3)+1000
		camera.lookAt( new THREE.Vector3(10000,0,10000))
	})

	onRenderFcts.push(function(){
		renderer.render( scene, camera );		
	})

	var lastTimeMsec= null
	requestAnimationFrame(function animate(nowMsec){
		// keep looping
		requestAnimationFrame( animate );
		// measure time
		lastTimeMsec	= lastTimeMsec || nowMsec-1000/60
		var deltaMsec	= Math.min(200, nowMsec - lastTimeMsec)
		lastTimeMsec	= nowMsec
		// call each update function
		onRenderFcts.forEach(function(onRenderFct){
			onRenderFct(deltaMsec/1000, nowMsec/1000)
		})
	})
</script></body>
