
<!DOCTYPE html>
<script type="text/javascript" src="https://code.jquery.com/jquery-2.1.3.min.js"></script>
<script src='threex.min.js'></script>
<script src='FlyControls.js'></script>
<script src='SimplexNoise.js'></script>
<script src='threex.GeometryUtils.js'></script>
<script src='threex.terrain.js'></script>
<script src='threex.grass.js'></script>
<script src="dat.js"></script>
<script src="Mirror.js"></script>
<script src="Sky.js"></script>
<script src="WaterShader.js"></script>

<script id="vertexShader" type="x-shader/x-vertex">
uniform sampler2D bumpTexture;
uniform float bumpScale;
varying float vAmount;
varying vec2 vUV;

void main() 
{ 
	vUV = uv;
	vec4 bumpData = texture2D( bumpTexture, uv );	
	vAmount = bumpData.r+0.07;
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}
</script>

<script id="fragmentShader" type="x-shader/x-vertex"> 
uniform sampler2D oceanTexture;
uniform sampler2D sandyTexture;
uniform sampler2D grassTexture;
uniform sampler2D rockyTexture;
uniform sampler2D snowyTexture;
varying vec2 vUV;
varying float vAmount;

void main() 
{

	vec4 water = (smoothstep(0.01, 0.15, vAmount) - smoothstep(0.14, 0.16, vAmount)) * texture2D( oceanTexture, vUV * 10.0 );
	vec4 sandy = (smoothstep(0.14, 0.16, vAmount) - smoothstep(0.28, 0.31, vAmount)) * texture2D( sandyTexture, vUV * 10.0 );
	vec4 grass = (smoothstep(0.28, 0.32, vAmount) - smoothstep(0.35, 0.40, vAmount)) * texture2D( grassTexture, vUV * 20.0 );
	vec4 rocky = (smoothstep(0.30, 0.50, vAmount) - smoothstep(0.80, 0.95, vAmount)) * texture2D( rockyTexture, vUV * 20.0 );
	vec4 snowy = (smoothstep(0.80, 0.95, vAmount))                                   * texture2D( snowyTexture, vUV * 10.0 );
	gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0) +water + sandy + grass + rocky + snowy; //, 1.0);
}  
</script>
<body style='margin: 0px; background-color: #bbbbbb; overflow: hidden;'>
<div id="pos" style="position:absolute;top:0px;left:0px;color:white;">test</div>
<div id="pos2" style="position:absolute;top:20px;left:0px;color:white;">test</div>
<div id="blocker"></div>
<div id="instructions"></div>
<script>

function initSky(){

				// Add Sky Mesh
				sky = new THREE.Sky();
				scene.add( sky.mesh );


				// Add Sun Helper
				sunSphere = new THREE.Mesh( new THREE.SphereGeometry( 20000, 30, 30 ),
					new THREE.MeshBasicMaterial({color: 0xffffff, wireframe: false }));
				sunSphere.position.y = -700000;
				sunSphere.visible = true;
				scene.add( sunSphere );

				/// GUI

				var effectController  = {
					turbidity: 10,
					reileigh: 2,
					mieCoefficient: 0.005,
					mieDirectionalG: 0.8,
					luminance: 1,
					inclination: 0.49, // elevation / inclination
					azimuth: 0.25, // Facing front,
					sun: !true
				}

				var distance = 400000;

				function guiChanged() {
					var uniforms = sky.uniforms;
					uniforms.turbidity.value = effectController.turbidity;
					uniforms.reileigh.value = effectController.reileigh;
					uniforms.luminance.value = effectController.luminance;
					uniforms.mieCoefficient.value = effectController.mieCoefficient;
					uniforms.mieDirectionalG.value = effectController.mieDirectionalG;

					var theta = Math.PI * (effectController.inclination - 0.5);
					var phi = 2 * Math.PI * (effectController.azimuth - 0.5);

					sunSphere.position.x = distance * Math.cos(phi);
					sunSphere.position.y = distance * Math.sin(phi) * Math.sin(theta);
					sunSphere.position.z = distance * Math.sin(phi) * Math.cos(theta);

					sunSphere.visible = effectController.sun;

					sky.uniforms.sunPosition.value.copy(sunSphere.position);

				}


				var gui = new dat.GUI();


				gui.add( effectController, "turbidity", 1.0, 20.0, 0.1 ).onChange( guiChanged );
				gui.add( effectController, "reileigh", 0.0, 4, 0.001 ).onChange( guiChanged );
				gui.add( effectController, "mieCoefficient", 0.0, 0.1, 0.001 ).onChange( guiChanged );
				gui.add( effectController, "mieDirectionalG", 0.0, 1, 0.001 ).onChange( guiChanged );
				gui.add( effectController, "luminance", 0.0, 2).onChange( guiChanged );;
				gui.add( effectController, "inclination", 0, 1, 0.0001).onChange( guiChanged );
				gui.add( effectController, "azimuth", 0, 1, 0.0001).onChange( guiChanged );
				gui.add( effectController, "sun").onChange( guiChanged );


				guiChanged();


				camera.lookAt(sunSphere.position)


			}

	var loadImage = function(url) {
	    return THREE.ImageUtils.loadTexture(url,null,function(){});
	}

	var TILES = 6

	var moveForward = false;
	var moveBackward = false;
	var moveLeft = false;
	var moveRight = false;
	var gmesh,water,hemiLight,light;
	var posgrass = [];
	var posgrass2 = [];
	var posgrass3 = [];
	var posgrass4 = [];
	var  controls;
	var controlsEnabled = false;
	var renderer	= new THREE.WebGLRenderer();
	renderer.setSize( window.innerWidth, window.innerHeight );
	document.body.appendChild( renderer.domElement );
	var velocity = new THREE.Vector3();
	var onRenderFcts= [];
	var scene	= new THREE.Scene();
	var camera	= new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.01, 1000000);
	controls = new THREE.PointerLockControls( camera );
	scene.add( controls.getObject() );
	var blocker = document.getElementById( 'blocker' );
	var instructions = document.getElementById( 'instructions' );
	if ( document.pointerLockElement === element || document.mozPointerLockElement === element || document.webkitPointerLockElement === element ) {

						controlsEnabled = true;
						controls.enabled = true;
						blocker.style.display = 'none';

					} else {

						controls.enabled = false;
						blocker.style.display = '-webkit-box';
						blocker.style.display = '-moz-box';
						blocker.style.display = 'box';
						instructions.style.display = '';
					}

			var havePointerLock = 'pointerLockElement' in document || 'mozPointerLockElement' in document || 'webkitPointerLockElement' in document;
			if ( havePointerLock ) {

				var element = document.body;

				var pointerlockchange = function ( event ) {

					if ( document.pointerLockElement === element || document.mozPointerLockElement === element || document.webkitPointerLockElement === element ) {

						controlsEnabled = true;
						controls.enabled = true;

						blocker.style.display = 'none';

					} else {

						controls.enabled = false;

						blocker.style.display = '-webkit-box';
						blocker.style.display = '-moz-box';
						blocker.style.display = 'box';

						instructions.style.display = '';

					}

				}

				var pointerlockerror = function ( event ) {

					instructions.style.display = '';

				}

				// Hook pointer lock state change events
				document.addEventListener( 'pointerlockchange', pointerlockchange, false );
				document.addEventListener( 'mozpointerlockchange', pointerlockchange, false );
				document.addEventListener( 'webkitpointerlockchange', pointerlockchange, false );

				document.addEventListener( 'pointerlockerror', pointerlockerror, false );
				document.addEventListener( 'mozpointerlockerror', pointerlockerror, false );
				document.addEventListener( 'webkitpointerlockerror', pointerlockerror, false );

				instructions.addEventListener( 'click', function ( event ) {

					instructions.style.display = 'none';

					// Ask the browser to lock the pointer
					element.requestPointerLock = element.requestPointerLock || element.mozRequestPointerLock || element.webkitRequestPointerLock;

					if ( /Firefox/i.test( navigator.userAgent ) ) {

						var fullscreenchange = function ( event ) {

							if ( document.fullscreenElement === element || document.mozFullscreenElement === element || document.mozFullScreenElement === element ) {

								document.removeEventListener( 'fullscreenchange', fullscreenchange );
								document.removeEventListener( 'mozfullscreenchange', fullscreenchange );

								element.requestPointerLock();
							}

						}

						document.addEventListener( 'fullscreenchange', fullscreenchange, false );
						document.addEventListener( 'mozfullscreenchange', fullscreenchange, false );

						element.requestFullscreen = element.requestFullscreen || element.mozRequestFullscreen || element.mozRequestFullScreen || element.webkitRequestFullscreen;

						element.requestFullscreen();

					} else {

						element.requestPointerLock();

					}

				}, false );

			} else {

				instructions.innerHTML = 'Your browser doesn\'t seem to support Pointer Lock API';

			}

			
	var onKeyDown = function ( event ) {

					switch ( event.keyCode ) {

						case 38: // up
						case 87: // w
							moveForward = true;
							break;

						case 37: // left
						case 65: // a
							moveLeft = true; break;

						case 40: // down
						case 83: // s
							moveBackward = true;
							break;

						case 39: // right
						case 68: // d
							moveRight = true;
							break;

						case 32: // space
							if ( canJump === true ) velocity.y += 350;
							canJump = false;
							break;

					}

				};

				var onKeyUp = function ( event ) {

					switch( event.keyCode ) {

						case 38: // up
						case 87: // w
							moveForward = false;
							break;

						case 37: // left
						case 65: // a
							moveLeft = false;
							break;

						case 40: // down
						case 83: // s
							moveBackward = false;
							break;

						case 39: // right
						case 68: // d
							moveRight = false;
							break;

					}

				};

				document.addEventListener( 'keydown', onKeyDown, false );
				document.addEventListener( 'keyup', onKeyUp, false );

//				controls.addEventListener( 'change', render );

//				camera.lookAt( new THREE.Vector3(0,0,0))
	;(function(){
/*		var light	= new THREE.AmbientLight( 0x666666)
		scene.add( light )
		var light	= new THREE.DirectionalLight('0xccddee', 2)
		light.position.set(0.5, 0.0, 2)
		scene.add( light )
		var light	= new THREE.DirectionalLight('white', 5)
		light.position.set(0.5, 0.0, 2)
		scene.add( light )
		*/ light	= new THREE.DirectionalLight('white', 0.75*2)
		light.position.set(-0.5, -0.5, -2)
		scene.add( light )		
		hemiLight = new THREE.HemisphereLight( 0xffffff, 0xffffff, .5 ); 
		scene.add( hemiLight )		
		
	})()

var cube
var heightMap,mesh,geometry,material;
var heightMaps,meshes,geometries,materials;
heightMaps=[];
meshes=[];
geometries=[];
materials=[];

var oceanTexture = new loadImage( 'dirt-512.jpg' );
oceanTexture.wrapS = oceanTexture.wrapT = THREE.RepeatWrapping; 

var sandyTexture = new loadImage( 'sand-512.jpg' );
sandyTexture.wrapS = sandyTexture.wrapT = THREE.RepeatWrapping; 

var grassTexture = new loadImage( 'grass-512.jpg' );
grassTexture.wrapS = grassTexture.wrapT = THREE.RepeatWrapping; 

var rockyTexture = new loadImage( 'rock-512.jpg' );
rockyTexture.wrapS = rockyTexture.wrapT = THREE.RepeatWrapping; 

var snowyTexture = new loadImage( 'snow-512.jpg' );
snowyTexture.wrapS = snowyTexture.wrapT = THREE.RepeatWrapping; 



for (var i = 0; i < TILES; i++) {
for (var j = 0; j < TILES; j++) {

	
addTile(i,j)

}
}
/*		 var posgrass = [];
		 posgrass.push(new THREE.Vector3(0,0,0));
		 posgrass.push(new THREE.Vector3(100,0,100));
		 posgrass.push(new THREE.Vector3(200,0,200));
		 posgrass.push(new THREE.Vector3(300,0,300));
		 posgrass.push(new THREE.Vector3(400,0,400));
		 posgrass.push(new THREE.Vector3(500,0,500));*/
//		 posgrass.push(new THREE.Vector3(100,100,100));
//		 posgrass.push(new THREE.Vector3(12,12,12));

gmesh    = new THREEx.createGrassTufts(posgrass,'images/grass01.png')
scene.add(gmesh)
gmesh    = new THREEx.createGrassTufts(posgrass2,'images/grass02.png')
scene.add(gmesh)
gmesh    = new THREEx.createGrassTufts(posgrass3,'images/flowers01.png')
scene.add(gmesh)
gmesh    = new THREEx.createGrassTufts(posgrass4,'images/flowers02.png')
scene.add(gmesh)


initSky();

var parameters = {
				width: 10000,
				height: 10000,
				widthSegments: 500,
				heightSegments: 500,
				depth: 1500,
				param: 1,
				filterparam: 1
			}
			
			var waterNormals;

		
				
				waterNormals = new THREE.ImageUtils.loadTexture( 'images/waternormals.jpg' );
				waterNormals.wrapS = waterNormals.wrapT = THREE.RepeatWrapping; 

				water = new THREE.Water( renderer, camera, scene, {
					textureWidth: 512, 
					textureHeight: 512,
					waterNormals: waterNormals,
					alpha: 	1.0,
					sunDirection: light.position.clone().normalize(),
					sunColor: 0xffffff,
					waterColor: 0x001e0f,
					distortionScale: 50.0,
				} );


				mirrorMesh = new THREE.Mesh(
					new THREE.PlaneBufferGeometry( parameters.width, parameters.height ),
					water.material
				);

				mirrorMesh.add( water );
				mirrorMesh.rotation.x = - Math.PI * 0.5;
				mirrorMesh.position.y = - 150;
				mirrorMesh.position.x =  500;
				mirrorMesh.position.z =  500;	
				mirrorMesh.scale.multiplyScalar(1) 

				scene.add( mirrorMesh );



function addTile(x,y) {

	 heightMap	= THREEx.Terrain.allocateHeightMap(64, 64)
	THREEx.Terrain.simplexHeightMap(heightMap,63*x,63*y)

	 geometry	= THREEx.Terrain.heightMapToPlaneGeometry(heightMap,i,j)
	THREEx.Terrain.heightMapToVertexColor(heightMap, geometry)

	var canvas	= THREEx.Terrain.heightMapToCanvas(heightMap)

	document.body.appendChild(canvas)


var texture = new THREE.Texture(canvas);
texture.needsUpdate = true;

	var customUniforms = {
		bumpTexture:	{ type: "t", value: texture },
		bumpScale:	    { type: "f", value: 1.0 },
		oceanTexture:	{ type: "t", value: oceanTexture },
		sandyTexture:	{ type: "t", value: sandyTexture },
		grassTexture:	{ type: "t", value: grassTexture },
		rockyTexture:	{ type: "t", value: rockyTexture },
		snowyTexture:	{ type: "t", value: snowyTexture },
	};
	
	var material = new THREE.ShaderMaterial( 
	{
	    uniforms: customUniforms,
		vertexShader:   document.getElementById( 'vertexShader'   ).textContent,
		fragmentShader: document.getElementById( 'fragmentShader' ).textContent,
	}   );
	 mesh	= new THREE.Mesh( geometry, material );
	scene.add( mesh );
	mesh.position.x	= 1000*x+500
	mesh.position.z	= 1000*y+500
    mesh.scale.z	= 0.01

	mesh.rotateX(-Math.PI/2)
	mesh.scale.multiplyScalar(1000) 

	heightMaps[x*TILES+y]=heightMap;
	meshes[x*TILES+y]=mesh;
	geometries[x*TILES+y]=geometry;
	materials[x*TILES+y]=material;

}

	
	onRenderFcts.push(function(delta, now){
//		camera.position.x += (mouse.x*500000 - camera.position.x) 
//		camera.position.z+= (mouse.y*500000 - (camera.position.z))

				//controls.movementSpeed = 0.33 ;
//				controls.update();

if ( controlsEnabled ) {
					//raycaster.ray.origin.copy( controls.getObject().position );
					//raycaster.ray.origin.y -= 10;

					//var intersections = raycaster.intersectObjects( objects );

					//var isOnObject = intersections.length > 0;

					//var time = performance.now();
					//var delta = ( time - prevTime ) / 1000;

					velocity.x -= velocity.x * 10.0 * delta;
					velocity.z -= velocity.z * 10.0 * delta;

					velocity.y -= 9.8 * 100.0 * delta; // 100.0 = mass

					if ( moveForward ) velocity.z -= 400.0 * delta*100;
					if ( moveBackward ) velocity.z += 400.0 * delta*100;

					if ( moveLeft ) velocity.x -= 400.0 * delta*100;
					if ( moveRight ) velocity.x += 400.0 * delta*100;

					controls.getObject().translateX( velocity.x * delta );
					//controls.getObject().translateY( velocity.y * delta );
					controls.getObject().translateZ( velocity.z * delta );
/*
					if ( controls.getObject().position.y < 10 ) {

						velocity.y = 0;
						controls.getObject().position.y = 10;

						canJump = true;

					}
*/
					//prevTime = time;

				}
		//console.log(camera.position)
		//if (camera.position.x==NaN)camera.position=new Vector3(0,0,0)
		cx=controls.getObject().position.x%1000;
		cz=controls.getObject().position.z%1000;
		tcx=Math.floor(controls.getObject().position.x/1000)*TILES;
		tcz=Math.floor(controls.getObject().position.z/1000);
		//console.log(tcx+tcz)
		if (controls.getObject().position.x<1+1 || controls.getObject().position.z<1+1
//			||
//			controls.getObject().position.x>1000*TILES-1 || controls.getObject().position.z >1000*TILES-1
)
			controls.getObject().position.y=-100
		else {

//		controls.getObject().position.y=THREEx.Terrain.planeToHeightMapCoords(heightMaps[tcx+tcz], meshes[tcx+tcz], cx/2, cz/2)+400


	controls.getObject().position.y=THREEx.Terrain.planeToHeightMapCoords(heightMaps[tcx+tcz], meshes[tcx+tcz], cx, cz)+20
		if (controls.getObject().position.y<-100)controls.getObject().position.y=-100
		}

//				mirrorMesh.position.y = - 1600;
				mirrorMesh.position.x =  controls.getObject().position.x;
				mirrorMesh.position.z =  controls.getObject().position.z;
$('#pos').html(Math.round(controls.getObject().position.x)+' '+Math.round(controls.getObject().position.y)+' '+Math.round(controls.getObject().position.z))


		//camera.lookAt( new THREE.Vector3(100000,-2000,100000))
//gmesh.rotation.y+=.1;

		
//				controls.movementSpeed = 1;
//				controls.update( delta );
	})

	onRenderFcts.push(function(){
				water.material.uniforms.time.value += 1.0 / 60.0;
				
				water.render();
		renderer.render( scene, camera );		
	})

	var lastTimeMsec= null
	requestAnimationFrame(function animate(nowMsec){
		requestAnimationFrame( animate );
		lastTimeMsec	= lastTimeMsec || nowMsec-1000/60
		var deltaMsec	= Math.min(200, nowMsec - lastTimeMsec)
		lastTimeMsec	= nowMsec
		onRenderFcts.forEach(function(onRenderFct){
			onRenderFct(deltaMsec/1000, nowMsec/1000)
		})
	})
</script>
</body>
