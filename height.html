
<!DOCTYPE html>
<script src='https://cdnjs.cloudflare.com/ajax/libs/three.js/r71/three.js'></script>
<script src='FlyControls.js'></script>
<script src='SimplexNoise.js'></script>
<script src='threex.terrain.js'></script>
<script id="vertexShader" type="x-shader/x-vertex">
uniform sampler2D bumpTexture;
uniform float bumpScale;

varying float vAmount;
varying vec2 vUV;

void main() 
{ 
	vUV = uv;
	vec4 bumpData = texture2D( bumpTexture, uv );
	
	vAmount = bumpData.r+0.07; // assuming map is grayscale it doesn't matter if you use r, g, or b.
	
	// move the position along the normal
    //vec3 newPosition = position + normal* bumpScale * 1.0;
	
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}
</script>

<script id="fragmentShader" type="x-shader/x-vertex"> 
uniform sampler2D oceanTexture;
uniform sampler2D sandyTexture;
uniform sampler2D grassTexture;
uniform sampler2D rockyTexture;
uniform sampler2D snowyTexture;

varying vec2 vUV;

varying float vAmount;

void main() 
{

	vec4 water = (smoothstep(0.01, 0.25, vAmount) - smoothstep(0.24, 0.26, vAmount)) * texture2D( oceanTexture, vUV * 10.0 );
	vec4 sandy = (smoothstep(0.24, 0.27, vAmount) - smoothstep(0.28, 0.31, vAmount)) * texture2D( sandyTexture, vUV * 10.0 );
	vec4 grass = (smoothstep(0.28, 0.32, vAmount) - smoothstep(0.35, 0.40, vAmount)) * texture2D( grassTexture, vUV * 20.0 );
	vec4 rocky = (smoothstep(0.30, 0.50, vAmount) - smoothstep(0.40, 0.70, vAmount)) * texture2D( rockyTexture, vUV * 20.0 );
	vec4 snowy = (smoothstep(0.50, 0.65, vAmount))                                   * texture2D( snowyTexture, vUV * 10.0 );
	gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0) +water + sandy + grass + rocky + snowy; //, 1.0);
}  
</script>
<body style='margin: 0px; background-color: #bbbbbb; overflow: hidden;'><script>
	var renderer	= new THREE.WebGLRenderer();
	renderer.setSize( window.innerWidth, window.innerHeight );
	document.body.appendChild( renderer.domElement );
var loadImage = function(url) {
    return THREE.ImageUtils.loadTexture(url,null,function(){});
}
var  controls;
	var onRenderFcts= [];
	var scene	= new THREE.Scene();
	var camera	= new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.01, 1000000);
	camera.position.z = 180
/*controls = new THREE.FlyControls( camera );
container = document.createElement( 'div' );
				document.body.appendChild( container );
				controls.movementSpeed = 100;
				controls.domElement = container;
				controls.rollSpeed = Math.PI / 12;
				controls.autoForward = false;
				controls.dragToLook = false;*/

				camera.lookAt( new THREE.Vector3(0,0,0))
	;(function(){
		var light	= new THREE.AmbientLight( 0x666666)
		scene.add( light )
		var light	= new THREE.DirectionalLight('0xccddee', 2)
		light.position.set(0.5, 0.0, 2)
		scene.add( light )
		var light	= new THREE.DirectionalLight('white', 5)
		light.position.set(0.5, 0.0, 2)
		scene.add( light )
		var light	= new THREE.DirectionalLight('white', 0.75*2)
		light.position.set(-0.5, -0.5, -2)
		scene.add( light )		
		hemiLight = new THREE.HemisphereLight( 0x0000ff, 0x00ff00, 0.6 ); 
		scene.add( hemiLight )		
		
	})()

var cube
var heightMap,mesh,geometry,material;
var heightMaps,meshes,geometries,materials;
heightMaps=[];
meshes=[];
geometries=[];
materials=[];

var oceanTexture = new loadImage( 'dirt-512.jpg' );
oceanTexture.wrapS = oceanTexture.wrapT = THREE.RepeatWrapping; 

var sandyTexture = new loadImage( 'sand-512.jpg' );
sandyTexture.wrapS = sandyTexture.wrapT = THREE.RepeatWrapping; 

var grassTexture = new loadImage( 'grass-512.jpg' );
grassTexture.wrapS = grassTexture.wrapT = THREE.RepeatWrapping; 

var rockyTexture = new loadImage( 'rock-512.jpg' );
rockyTexture.wrapS = rockyTexture.wrapT = THREE.RepeatWrapping; 

var snowyTexture = new loadImage( 'snow-512.jpg' );
snowyTexture.wrapS = snowyTexture.wrapT = THREE.RepeatWrapping; 



for (var i = 0; i < 5; i++) {
for (var j = 0; j < 5; j++) {

	 heightMap	= THREEx.Terrain.allocateHeightMap(64, 64)
	THREEx.Terrain.simplexHeightMap(heightMap,63*i,63*j)
		
	 geometry	= THREEx.Terrain.heightMapToPlaneGeometry(heightMap)
	THREEx.Terrain.heightMapToVertexColor(heightMap, geometry)

	var canvas	= THREEx.Terrain.heightMapToCanvas(heightMap)

	document.body.appendChild(canvas)


var texture = new THREE.Texture(canvas);
texture.needsUpdate = true;

	var customUniforms = {
		bumpTexture:	{ type: "t", value: texture },
		bumpScale:	    { type: "f", value: 1.0 },
		oceanTexture:	{ type: "t", value: oceanTexture },
		sandyTexture:	{ type: "t", value: sandyTexture },
		grassTexture:	{ type: "t", value: grassTexture },
		rockyTexture:	{ type: "t", value: rockyTexture },
		snowyTexture:	{ type: "t", value: snowyTexture },
	};
	
	var material = new THREE.ShaderMaterial( 
	{
	    uniforms: customUniforms,
		vertexShader:   document.getElementById( 'vertexShader'   ).textContent,
		fragmentShader: document.getElementById( 'fragmentShader' ).textContent,
	}   );
	 mesh	= new THREE.Mesh( geometry, material );
	scene.add( mesh );
	mesh.position.x	= 10000*i+5000
	mesh.position.z	= 10000*j+5000
    mesh.scale.z	= 0.01

	mesh.rotateX(-Math.PI/2)
	mesh.scale.multiplyScalar(10000) 

	heightMaps[heightMaps.length]=heightMap;
	meshes[meshes.length]=mesh;
	geometries[geometries.length]=geometry;
	materials[materials.length]=material;

}
}	
console.log(meshes);
cube = new THREE.Mesh( new THREE.CubeGeometry( 200, 200, 200 ), new THREE.MeshNormalMaterial() );
	cube.position.x = 0;
	cube.position.z = 0;
	cube.position.y = THREEx.Terrain.planeToHeightMapCoords(heightMaps[0], meshes[0], cube.position.x,cube.position.z);

	scene.add(cube);

	onRenderFcts.push(function(delta){
cube.position.x +=10;
	})


	var mouse	= {x : 0, y : 0}
	document.addEventListener('mousemove', function(event){
		mouse.x	= (event.clientX / window.innerWidth ) - 0.5
		mouse.y	= (event.clientY / window.innerHeight) - 0.5
	}, false)
	onRenderFcts.push(function(delta, now){
		camera.position.x += (mouse.x*50000 - camera.position.x) * (delta*3)+10
		camera.position.z+= (mouse.y*50000 - (camera.position.z)) * (delta*3)+10

		if (camera.position.x<1+1) camera.position.x=1+1; 
		if (camera.position.z<1+1) camera.position.z=1+1;  
		cx=camera.position.x%10000;
		cz=camera.position.z%10000;
		tcx=Math.floor(camera.position.x/10000)*5;
		tcz=Math.floor(camera.position.z/10000);
		console.log(tcx+' + '+tcz+' ')
		console.log(camera.position)
		camera.position.y=THREEx.Terrain.planeToHeightMapCoords(heightMaps[tcx+tcz], meshes[tcx+tcz], camera.position.x, camera.position.z)+20
		camera.lookAt( new THREE.Vector3(50000,-300,50000))

//				controls.movementSpeed = 1;
//				controls.update( delta );
	})

	onRenderFcts.push(function(){

		renderer.render( scene, camera );		
	})

	var lastTimeMsec= null
	requestAnimationFrame(function animate(nowMsec){
		requestAnimationFrame( animate );
		lastTimeMsec	= lastTimeMsec || nowMsec-1000/60
		var deltaMsec	= Math.min(200, nowMsec - lastTimeMsec)
		lastTimeMsec	= nowMsec
		onRenderFcts.forEach(function(onRenderFct){
			onRenderFct(deltaMsec/1000, nowMsec/1000)
		})
	})
</script></body>
